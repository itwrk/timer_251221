<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>タスク編集 - ライフリッスンタイマー</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    /* 編集画面専用スタイル (1行表示向け) */
    .edit-container { max-width: 1000px; margin: 0 auto; }
    .page-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .back-link { color: #3498db; text-decoration: none; font-weight: bold; font-size: 16px; }
    
    .task-edit-card { 
      background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); 
      margin-bottom: 30px; overflow: hidden; border: 1px solid #eee;
    }
    .task-edit-header { 
      background: #f8f9fa; padding: 10px 15px; border-bottom: 1px solid #eee; 
      display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;
    }
    .task-title-group { display: flex; align-items: center; gap: 10px; flex: 1; }
    .task-icon-display { font-size: 24px; color: #3498db; cursor: pointer; width: 40px; text-align: center; }
    .task-name-edit { 
      font-size: 18px; font-weight: bold; border: 1px solid #ddd; padding: 5px 10px; 
      border-radius: 4px; width: 200px; max-width: 100%;
    }
    
    .step-list { padding: 0; }
    .step-item { 
      display: flex; align-items: center; padding: 8px 10px; border-bottom: 1px solid #eee; 
      gap: 8px; background: #fff; flex-wrap: wrap;
    }
    .step-item:nth-child(even) { background: #fafafa; }
    .sortable-ghost { opacity: 0.4; background: #e8f4fd; }
    
    .step-handle { cursor: grab; color: #ccc; padding: 5px; flex-shrink: 0; }
    .step-handle:hover { color: #3498db; }
    
    /* 1行レイアウト用の入力グループ */
    .step-inputs-row { display: flex; flex: 1; gap: 5px; flex-wrap: wrap; align-items: center; }
    
    .input-wrapper { display: flex; flex-direction: column; min-width: 80px; }
    .input-wrapper.wide { flex: 2; min-width: 150px; }
    .input-wrapper.memo { flex: 1.5; }
    .input-wrapper.time { flex: 0 0 130px; }
    
    .label-mini { font-size: 10px; color: #999; margin-bottom: 2px; white-space: nowrap; }
    .edit-input { width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 13px; }
    
    .time-control { display: flex; flex-direction: column; gap: 2px; }
    .time-row-main { display: flex; align-items: center; gap: 3px; }
    .time-row-btns { display: flex; gap: 2px; justify-content: flex-end; }
    
    .tb-btn { padding: 2px 5px; font-size: 10px; background: #eee; border-radius: 3px; border: 1px solid #ccc; cursor: pointer; }
    .tb-btn:hover { background: #e0e0e0; }
    
    .step-delete { margin-left: auto; }
    
    .add-step-btn-area { padding: 10px; text-align: center; background: #fff; }
    .reset-area { margin-top: 50px; padding: 20px; background: #fff0f0; border-radius: 8px; text-align: center; }
    .reset-btn { background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 4px; font-weight: bold; cursor: pointer; }
    
    .modal { z-index: 9999; }
    
    /* スマホ対応 */
    @media (max-width: 600px) {
      .step-item { align-items: flex-start; }
      .step-inputs-row { flex-direction: column; width: 100%; align-items: stretch; }
      .input-wrapper { width: 100%; margin-bottom: 5px; }
      .step-handle { padding-top: 10px; }
    }
  </style>
</head>
<body>
  
  <div id="iconModal" class="modal hidden">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h2>アイコンを選択</h2>
      <div class="icon-grid" id="presetIconGrid"></div>
    </div>
  </div>

  <div class="container edit-container">
    <div class="page-header">
      <h1><i class="fas fa-edit"></i> タスク編集</h1>
      <a href="index.html" class="back-link"><i class="fas fa-arrow-left"></i> タイマーに戻る</a>
    </div>

    <div id="taskListContainer"></div>
    
    <div style="text-align: center; margin-top: 40px;">
        <a href="index.html" class="action-btn" style="text-decoration: none; display: inline-block; width: 200px; text-align: center;">完了して戻る</a>
    </div>
    
    <div class="reset-area">
        <p>※表示がおかしい場合やデータを初期化したい場合</p>
        <button class="reset-btn" onclick="resetAllData()">データを初期化してリロード</button>
    </div>
  </div>

  <script>
    const STORAGE_KEYS = { ALL_TASKS: 'lifelisten_timer_all_tasks', LAST_CSV: 'lifelisten_timer_last_csv' };
    const PRESET_ICONS = [
      'fa-solid fa-bath', 'fa-solid fa-toilet', 'fa-solid fa-bed', 'fa-solid fa-utensils',
      'fa-solid fa-fire-burner', 'fa-solid fa-broom', 'fa-solid fa-briefcase', 'fa-solid fa-droplet',
      'fa-solid fa-face-smile', 'fa-solid fa-sun', 'fa-solid fa-person-running', 'fa-solid fa-person-walking',
      'fa-solid fa-bicycle', 'fa-solid fa-train', 'fa-solid fa-shirt', 'fa-solid fa-tooth',
      'fa-solid fa-book', 'fa-solid fa-laptop', 'fa-solid fa-mobile-screen', 'fa-solid fa-cart-shopping',
      'fa-solid fa-yen-sign', 'fa-solid fa-mug-hot', 'fa-solid fa-wine-glass', 'fa-solid fa-music',
      'fa-solid fa-trash-can', 'fa-solid fa-pills', 'fa-solid fa-hospital', 'fa-solid fa-heart',
      'fa-solid fa-star', 'fa-solid fa-headphones'
    ];

    let allTasks = [];
    let currentEditingTaskName = null;

    function loadTasks() {
      const data = localStorage.getItem(STORAGE_KEYS.ALL_TASKS);
      if (data) {
        allTasks = JSON.parse(data);
        renderAll();
      } else {
        // データがない場合はindexへ戻すか、メッセージを出す
        document.getElementById('taskListContainer').innerHTML = '<p>データがありません。トップページでデータを読み込んでください。</p>';
      }
    }

    function saveTasks() {
      localStorage.setItem(STORAGE_KEYS.ALL_TASKS, JSON.stringify(allTasks));
    }

    function renderAll() {
      const container = document.getElementById('taskListContainer');
      container.innerHTML = '';
      
      const taskGroups = {};
      const taskNames = [];
      allTasks.forEach(task => {
        const name = task['タスク名'];
        if (!taskGroups[name]) { taskGroups[name] = []; taskNames.push(name); }
        taskGroups[name].push(task);
      });

      taskNames.forEach(name => {
        const tasks = taskGroups[name];
        tasks.sort((a, b) => (a['順番'] || 0) - (b['順番'] || 0));
        const iconClass = tasks[0]['アイコン'] || 'fa-solid fa-headphones';

        const card = document.createElement('div');
        card.className = 'task-edit-card';
        card.innerHTML = `
          <div class="task-edit-header">
            <div class="task-title-group">
              <div class="task-icon-display" onclick="openIconModalForTask('${name}')"><i class="${iconClass}"></i></div>
              <input type="text" class="task-name-edit" value="${name}" onchange="changeTaskName('${name}', this.value)">
            </div>
            <div class="task-actions"><button class="delete-btn" style="padding:5px 10px; font-size:12px;" onclick="deleteTaskGroup('${name}')">削除</button></div>
          </div>
          <div class="step-list" id="steps-${name}"></div>
          <div class="add-step-btn-area">
            <button class="action-btn" style="width: auto; padding:8px 15px; font-size:14px;" onclick="addStepToTask('${name}')"><i class="fas fa-plus"></i> ステップ追加</button>
          </div>
        `;
        
        const listContainer = card.querySelector(`#steps-${name}`);
        tasks.forEach((task, idx) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          item.setAttribute('data-id', allTasks.indexOf(task));
          
          item.innerHTML = `
            <div class="step-handle"><i class="fas fa-grip-vertical"></i></div>
            <div class="step-inputs-row">
                <div class="input-wrapper">
                    <span class="label-mini">項目名</span>
                    <input type="text" class="edit-input" value="${task['項目名'] || ''}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '項目名', this.value)">
                </div>
                <div class="input-wrapper wide">
                    <span class="label-mini">読み上げ</span>
                    <input type="text" class="edit-input" value="${task['読み上げテキスト'] || ''}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '読み上げテキスト', this.value)">
                </div>
                <div class="input-wrapper memo">
                    <span class="label-mini">メモ</span>
                    <input type="text" class="edit-input" value="${task['メモ'] || ''}" placeholder="メモ" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, 'メモ', this.value)">
                </div>
                <div class="input-wrapper time">
                    <span class="label-mini">秒数</span>
                    <div class="time-control">
                        <div class="time-row-main">
                            <input type="number" class="edit-input" style="text-align:center;" id="time-${allTasks.indexOf(task)}" value="${task['秒数'] || 30}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '秒数', this.value)">
                            <span>秒</span>
                        </div>
                        <div class="time-row-btns">
                            <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 30)">30</button>
                            <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 60)">60</button>
                            <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 180)">180</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="step-delete"><button class="delete-btn" style="padding:5px;" onclick="deleteStep(${allTasks.indexOf(task)})"><i class="fas fa-trash"></i></button></div>
          `;
          listContainer.appendChild(item);
        });
        
        // Sortable設定
        new Sortable(listContainer, {
            handle: '.step-handle',
            animation: 150,
            ghostClass: 'sortable-ghost',
            onEnd: function (evt) {
                // DOMの順番を元にデータの順番を更新
                const items = listContainer.querySelectorAll('.step-item');
                // 並び替え対象のタスクだけを抽出してインデックス再配置
                // 簡易実装：全データを舐めて、このグループの順番だけ書き換える
                let orderCounter = 1;
                items.forEach(item => {
                    const originalIdx = parseInt(item.getAttribute('data-id'));
                    allTasks[originalIdx]['順番'] = orderCounter++;
                });
                saveTasks();
                // 完全に整合性を取るため再描画
                setTimeout(renderAll, 100);
            }
        });
        
        container.appendChild(card);
      });
    }

    function updateTaskByIndex(index, field, value) {
      if (field === '秒数') value = parseInt(value);
      allTasks[index][field] = value;
      saveTasks();
    }

    function setStepTime(index, seconds) {
      document.getElementById(`time-${index}`).value = seconds;
      updateTaskByIndex(index, '秒数', seconds);
    }

    function changeTaskName(oldName, newName) {
      if (!newName) return;
      allTasks.forEach(t => { if (t['タスク名'] === oldName) t['タスク名'] = newName; });
      saveTasks(); renderAll();
    }

    function addStepToTask(taskName) {
      const tasks = allTasks.filter(t => t['タスク名'] === taskName);
      const maxOrder = Math.max(...tasks.map(t => t['順番'] || 0));
      const parentIcon = tasks[0]['アイコン'] || '';
      allTasks.push({
        'タスク名': taskName, '項目名': '新規ステップ', '読み上げテキスト': '新規ステップ', '秒数': 30,
        '順番': maxOrder + 1, 'アイコン': parentIcon, 'メモ': ''
      });
      saveTasks(); renderAll();
    }

    function deleteStep(index) {
      if (!confirm('削除しますか？')) return;
      allTasks.splice(index, 1);
      saveTasks(); renderAll();
    }

    function deleteTaskGroup(taskName) {
      if (!confirm(`タスク「${taskName}」を全て削除しますか？`)) return;
      allTasks = allTasks.filter(t => t['タスク名'] !== taskName);
      saveTasks(); renderAll();
    }
    
    function resetAllData() {
      if(confirm('全てのデータを削除し、初期状態に戻しますか？')) {
        localStorage.removeItem(STORAGE_KEYS.ALL_TASKS);
        window.location.href = 'index.html';
      }
    }

    const iconModal = document.getElementById('iconModal');
    const presetIconGrid = document.getElementById('presetIconGrid');
    function initModal() {
      presetIconGrid.innerHTML = '';
      PRESET_ICONS.forEach(icon => {
        const div = document.createElement('div');
        div.className = 'icon-item';
        div.innerHTML = `<i class="${icon}"></i>`;
        div.onclick = () => selectIcon(icon);
        presetIconGrid.appendChild(div);
      });
      document.querySelector('.close-modal').onclick = () => iconModal.classList.add('hidden');
      window.onclick = (e) => { if (e.target === iconModal) iconModal.classList.add('hidden'); };
    }
    function openIconModalForTask(taskName) {
      currentEditingTaskName = taskName;
      iconModal.classList.remove('hidden');
    }
    function selectIcon(iconClass) {
      if (currentEditingTaskName) {
        allTasks.forEach(t => { if (t['タスク名'] === currentEditingTaskName) t['アイコン'] = iconClass; });
        saveTasks(); renderAll();
      }
      iconModal.classList.add('hidden');
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadTasks();
      initModal();
    });
  </script>
</body>
</html>