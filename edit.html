<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>タスク編集 - ライフリッスンタイマー</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    /* 編集画面専用スタイル */
    .edit-container { max-width: 900px; margin: 0 auto; }
    .page-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .back-link { color: #3498db; text-decoration: none; font-weight: bold; font-size: 16px; }
    
    .task-edit-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); margin-bottom: 30px; overflow: hidden; }
    .task-edit-header { background: #f8f9fa; padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
    
    .task-title-group { display: flex; align-items: center; gap: 10px; flex: 1; }
    .task-icon-display { font-size: 24px; color: #3498db; cursor: pointer; width: 40px; text-align: center; }
    .task-name-edit { font-size: 18px; font-weight: bold; border: 1px solid #ddd; padding: 5px 10px; border-radius: 4px; width: 200px; }
    
    .task-actions { display: flex; gap: 10px; }
    
    .step-list { padding: 0; }
    .step-item { display: flex; padding: 15px; border-bottom: 1px solid #eee; gap: 10px; align-items: flex-start; flex-wrap: wrap; background: #fff; }
    .step-item:nth-child(even) { background: #fafafa; }
    .sortable-ghost { opacity: 0.4; background: #e8f4fd; }
    
    .step-handle { cursor: grab; color: #ccc; padding-top: 5px; }
    .step-col { display: flex; flex-direction: column; gap: 5px; }
    .step-col.main { flex: 2; min-width: 200px; }
    .step-col.time { flex: 1; min-width: 120px; }
    
    .step-label { font-size: 12px; color: #777; font-weight: bold; }
    .step-input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
    
    .time-buttons { display: flex; gap: 5px; margin-top: 5px; }
    .tb-btn { padding: 4px 8px; font-size: 11px; background: #e9ecef; border-radius: 3px; border: none; cursor: pointer; }
    .tb-btn:hover { background: #dbe2e8; }
    
    .step-delete { align-self: center; }
    .add-step-btn-area { padding: 15px; text-align: center; background: #fff; }
    
    .reset-area { margin-top: 50px; padding: 20px; background: #fff0f0; border-radius: 8px; text-align: center; }
    .reset-btn { background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 4px; font-weight: bold; cursor: pointer; }
    
    .modal { z-index: 9999; }
  </style>
</head>
<body>
  
  <div id="iconModal" class="modal hidden">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h2>アイコンを選択</h2>
      <div class="icon-grid" id="presetIconGrid"></div>
    </div>
  </div>

  <div class="container edit-container">
    <div class="page-header">
      <h1><i class="fas fa-edit"></i> タスク編集</h1>
      <a href="index.html" class="back-link"><i class="fas fa-arrow-left"></i> タイマーに戻る</a>
    </div>

    <div id="taskListContainer"></div>
    
    <div style="text-align: center; margin-top: 40px;">
        <a href="index.html" class="action-btn" style="text-decoration: none; display: inline-block; width: 200px; text-align: center;">完了して戻る</a>
    </div>
    
    <div class="reset-area">
        <p>※表示がおかしい、またはデータを初期状態（CSVの内容）に戻したい場合はこちら</p>
        <button class="reset-btn" onclick="resetAllData()">データを初期化してリロード</button>
    </div>
  </div>

  <script>
    const STORAGE_KEYS = { ALL_TASKS: 'lifelisten_timer_all_tasks', LAST_CSV: 'lifelisten_timer_last_csv' };
    const PRESET_ICONS = [
      'fa-solid fa-bath', 'fa-solid fa-toilet', 'fa-solid fa-bed', 'fa-solid fa-utensils',
      'fa-solid fa-fire-burner', 'fa-solid fa-broom', 'fa-solid fa-briefcase', 'fa-solid fa-droplet',
      'fa-solid fa-face-smile', 'fa-solid fa-sun', 'fa-solid fa-person-running', 'fa-solid fa-person-walking',
      'fa-solid fa-bicycle', 'fa-solid fa-train', 'fa-solid fa-shirt', 'fa-solid fa-tooth',
      'fa-solid fa-book', 'fa-solid fa-laptop', 'fa-solid fa-mobile-screen', 'fa-solid fa-cart-shopping',
      'fa-solid fa-yen-sign', 'fa-solid fa-mug-hot', 'fa-solid fa-wine-glass', 'fa-solid fa-music',
      'fa-solid fa-trash-can', 'fa-solid fa-pills', 'fa-solid fa-hospital', 'fa-solid fa-heart',
      'fa-solid fa-star', 'fa-solid fa-headphones'
    ];

    let allTasks = [];
    let currentEditingTaskName = null;

    function loadTasks() {
      const data = localStorage.getItem(STORAGE_KEYS.ALL_TASKS);
      if (data) {
        allTasks = JSON.parse(data);
        renderAll();
      }
    }

    function saveTasks() {
      localStorage.setItem(STORAGE_KEYS.ALL_TASKS, JSON.stringify(allTasks));
    }

    function renderAll() {
      const container = document.getElementById('taskListContainer');
      container.innerHTML = '';
      
      const taskGroups = {};
      const taskNames = [];
      allTasks.forEach(task => {
        const name = task['タスク名'];
        if (!taskGroups[name]) { taskGroups[name] = []; taskNames.push(name); }
        taskGroups[name].push(task);
      });

      taskNames.forEach(name => {
        const tasks = taskGroups[name];
        tasks.sort((a, b) => (a['順番'] || 0) - (b['順番'] || 0));
        const iconClass = tasks[0]['アイコン'] || 'fa-solid fa-headphones';

        const card = document.createElement('div');
        card.className = 'task-edit-card';
        card.innerHTML = `
          <div class="task-edit-header">
            <div class="task-title-group">
              <div class="task-icon-display" onclick="openIconModalForTask('${name}')"><i class="${iconClass}"></i></div>
              <input type="text" class="task-name-edit" value="${name}" onchange="changeTaskName('${name}', this.value)">
            </div>
            <div class="task-actions"><button class="delete-btn" onclick="deleteTaskGroup('${name}')">タスク削除</button></div>
          </div>
          <div class="step-list" id="steps-${name}"></div>
          <div class="add-step-btn-area">
            <button class="action-btn" style="width: auto;" onclick="addStepToTask('${name}')"><i class="fas fa-plus"></i> ステップを追加</button>
          </div>
        `;
        
        const listContainer = card.querySelector(`#steps-${name}`);
        tasks.forEach((task, idx) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          item.setAttribute('data-id', allTasks.indexOf(task)); // IDとしてindexを使用
          
          item.innerHTML = `
            <div class="step-handle"><i class="fas fa-grip-vertical"></i></div>
            <div class="step-col main">
              <span class="step-label">項目名</span>
              <input type="text" class="step-input" value="${task['項目名'] || ''}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '項目名', this.value)">
              <span class="step-label" style="margin-top:5px;">読み上げ</span>
              <input type="text" class="step-input" value="${task['読み上げテキスト'] || ''}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '読み上げテキスト', this.value)">
              <span class="step-label" style="margin-top:5px;">メモ</span>
              <input type="text" class="step-input" value="${task['メモ'] || ''}" placeholder="メモ" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, 'メモ', this.value)">
            </div>
            <div class="step-col time">
              <span class="step-label">秒数</span>
              <input type="number" class="step-input" id="time-${allTasks.indexOf(task)}" value="${task['秒数'] || 30}" onchange="updateTaskByIndex(${allTasks.indexOf(task)}, '秒数', this.value)">
              <div class="time-buttons">
                <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 30)">30s</button>
                <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 60)">1m</button>
                <button class="tb-btn" onclick="setStepTime(${allTasks.indexOf(task)}, 180)">3m</button>
              </div>
            </div>
            <div class="step-delete"><button class="delete-btn" onclick="deleteStep(${allTasks.indexOf(task)})"><i class="fas fa-trash"></i></button></div>
          `;
          listContainer.appendChild(item);
        });
        
        // SortableJSの適用（並び替え機能）
        new Sortable(listContainer, {
            handle: '.step-handle',
            animation: 150,
            ghostClass: 'sortable-ghost',
            onEnd: function (evt) {
                // 並び替え後のDOM順序に基づいて「順番」を更新
                const items = listContainer.querySelectorAll('.step-item');
                items.forEach((item, index) => {
                    const taskIdx = parseInt(item.getAttribute('data-id'));
                    allTasks[taskIdx]['順番'] = index + 1;
                });
                saveTasks();
            }
        });
        
        container.appendChild(card);
      });
    }

    function updateTaskByIndex(index, field, value) {
      if (field === '秒数') value = parseInt(value);
      allTasks[index][field] = value;
      saveTasks();
    }

    function setStepTime(index, seconds) {
      document.getElementById(`time-${index}`).value = seconds;
      updateTaskByIndex(index, '秒数', seconds);
    }

    function changeTaskName(oldName, newName) {
      if (!newName) return;
      allTasks.forEach(t => { if (t['タスク名'] === oldName) t['タスク名'] = newName; });
      saveTasks(); renderAll();
    }

    function addStepToTask(taskName) {
      const tasks = allTasks.filter(t => t['タスク名'] === taskName);
      const maxOrder = Math.max(...tasks.map(t => t['順番'] || 0));
      const parentIcon = tasks[0]['アイコン'] || '';
      allTasks.push({
        'タスク名': taskName, '項目名': '新規ステップ', '読み上げテキスト': '新規ステップ', '秒数': 30,
        '順番': maxOrder + 1, 'アイコン': parentIcon, 'メモ': ''
      });
      saveTasks(); renderAll();
    }

    function deleteStep(index) {
      if (!confirm('このステップを削除しますか？')) return;
      allTasks.splice(index, 1);
      saveTasks(); renderAll();
    }

    function deleteTaskGroup(taskName) {
      if (!confirm(`タスク「${taskName}」を全て削除しますか？`)) return;
      allTasks = allTasks.filter(t => t['タスク名'] !== taskName);
      saveTasks(); renderAll();
    }
    
    // データ初期化
    function resetAllData() {
      if(confirm('全てのデータを削除し、初期CSVファイルの状態に戻しますか？\n（編集した内容は消えます）')) {
        localStorage.removeItem(STORAGE_KEYS.ALL_TASKS);
        window.location.href = 'index.html';
      }
    }

    // アイコンモーダル
    const iconModal = document.getElementById('iconModal');
    const presetIconGrid = document.getElementById('presetIconGrid');
    function initModal() {
      presetIconGrid.innerHTML = '';
      PRESET_ICONS.forEach(icon => {
        const div = document.createElement('div');
        div.className = 'icon-item';
        div.innerHTML = `<i class="${icon}"></i>`;
        div.onclick = () => selectIcon(icon);
        presetIconGrid.appendChild(div);
      });
      document.querySelector('.close-modal').onclick = () => iconModal.classList.add('hidden');
      window.onclick = (e) => { if (e.target === iconModal) iconModal.classList.add('hidden'); };
    }
    function openIconModalForTask(taskName) {
      currentEditingTaskName = taskName;
      iconModal.classList.remove('hidden');
    }
    function selectIcon(iconClass) {
      if (currentEditingTaskName) {
        allTasks.forEach(t => { if (t['タスク名'] === currentEditingTaskName) t['アイコン'] = iconClass; });
        saveTasks(); renderAll();
      }
      iconModal.classList.add('hidden');
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadTasks();
      initModal();
    });
  </script>
</body>
</html>